// Code generated by flamingo.me/graphql, DO NOT EDIT.
//go:build !graphql
// +build !graphql

package graphql

import (
	"context"
	"encoding/json"
	"log"
	"reflect"

	"flamingo.me/dingo"
	"github.com/99designs/gqlgen/graphql"
	"github.com/spf13/cobra"
)

// Module is an autogenerated dingo Module to bind the root resolver
type Module struct{}

// Configure sets the graphql.ExecutableSchema binding via a provider, passing in the correct root resolver
func (*Module) Configure(injector *dingo.Injector) {
	injector.Bind(new(graphql.ExecutableSchema)).ToProvider(func(root *rootResolver) graphql.ExecutableSchema {
		return NewExecutableSchema(Config{Resolvers: root, Directives: root.directives()})
	})

	injector.BindMulti(new(cobra.Command)).ToProvider(func(root *rootResolver) *cobra.Command {
		return &cobra.Command{
			Use: "gql calls a gql function like 'go run main.go gql User.Todos '{\"Name\":\"User a\"}' ",
			Run: func(cmd *cobra.Command, args []string) {
				if len(args) == 0 {
					for k := range direct(root) {
						log.Println(k)
					}
					return
				} else if len(args) == 1 {
					v := reflect.ValueOf(direct(root)[args[0]])
					log.Printf("%s", v.Type().String())
					return
				}

				v := reflect.ValueOf(direct(root)[args[0]])
				in := make([]reflect.Value, v.Type().NumIn()-1)
				for i := 1; i < v.Type().NumIn(); i++ {
					in[i-1] = reflect.New(v.Type().In(i))
					log.Println(json.Unmarshal([]byte(args[i]), in[i-1].Interface()))
					in[i-1] = in[i-1].Elem()
				}
				res := v.Call(append([]reflect.Value{reflect.ValueOf(context.Background())}, in...))
				for _, r := range res {
					v, _ := json.Marshal(r.Interface())
					log.Print(string(v))
				}
			},
		}
	})
}
